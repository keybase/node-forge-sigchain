// Generated by IcedCoffeeScript 1.8.0-e
(function() {
  var Forge, Key, Keyring, Link, SIG_ID_SUFFIX, UID_HEX_LEN, UID_SUFFIX, akatch, athrow, btcjs, createHash, generate_proof, generate_v2_with_corruption, iced, kbpgp, make_esc, prng, proofs, unix_time, username_to_uid, __iced_k, __iced_k_noop, _ref, _ref1;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  make_esc = require('iced-error').make_esc;

  _ref = require('iced-utils').util, athrow = _ref.athrow, akatch = _ref.akatch, unix_time = _ref.unix_time;

  kbpgp = require('kbpgp');

  proofs = require('keybase-proofs');

  _ref1 = require('crypto'), prng = _ref1.prng, createHash = _ref1.createHash;

  btcjs = require('keybase-bitcoinjs-lib');

  UID_HEX_LEN = 32;

  UID_SUFFIX = "19";

  username_to_uid = function(un) {
    var hashlen;
    hashlen = UID_HEX_LEN - 2;
    return createHash('sha256').update(un).digest('hex').slice(0, hashlen) + UID_SUFFIX;
  };

  generate_v2_with_corruption = function(_arg, cb) {
    var armored, esc, hooks, id, inner, o, opts, out, outer, pgp, proof, raw, s, short_id, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    proof = _arg.proof, opts = _arg.opts, hooks = _arg.hooks;
    esc = make_esc(cb, "generate");
    out = null;
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced"
        });
        proof._v_generate({}, esc(__iced_deferrals.defer({
          lineno: 25
        })));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced"
          });
          proof.generate_json({}, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                s = arguments[0];
                return o = arguments[1];
              };
            })(),
            lineno: 26
          })));
          __iced_deferrals._fulfill();
        })(function() {
          inner = {
            str: s,
            obj: o
          };
          if (typeof hooks.pre_generate_outer === "function") {
            hooks.pre_generate_outer({
              proof: proof,
              inner: inner
            });
          }
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced"
            });
            proof.generate_outer({
              inner: inner
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return outer = arguments[0];
                };
              })(),
              lineno: 29
            })));
            __iced_deferrals._fulfill();
          })(function() {
            if (typeof hooks.post_generate_outer === "function") {
              hooks.post_generate_outer({
                proof: proof,
                outer: outer,
                inner: inner
              });
            }
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced"
              });
              proof.sig_eng.box(outer, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    pgp = arguments[0].pgp;
                    raw = arguments[0].raw;
                    return armored = arguments[0].armored;
                  };
                })(),
                lineno: 31
              })));
              __iced_deferrals._fulfill();
            })(function() {
              var _ref2;
              if (typeof hooks.corrupt_box === "function") {
                hooks.corrupt_box({
                  inner: inner,
                  outer: outer,
                  pgp: pgp,
                  raw: raw,
                  armored: armored
                });
              }
              _ref2 = proofs.make_ids(raw), short_id = _ref2.short_id, id = _ref2.id;
              if (typeof hooks.corrupt_ids === "function") {
                hooks.corrupt_ids({
                  inner: inner,
                  outer: outer,
                  pgp: pgp,
                  raw: raw,
                  armored: armored,
                  short_id: short_id,
                  id: id
                });
              }
              out = {
                pgp: pgp,
                id: id,
                short_id: short_id,
                raw: raw,
                armored: armored,
                inner: inner,
                outer: outer
              };
              return cb(null, out);
            });
          });
        });
      };
    })(this));
  };

  generate_proof = function(_arg, cb) {
    var hooks, linkdesc, proof;
    proof = _arg.proof, linkdesc = _arg.linkdesc;
    if ((hooks = linkdesc.corrupt_v2_proof_hooks) != null) {
      return generate_v2_with_corruption({
        proof: proof,
        opts: {},
        hooks: hooks
      }, cb);
    } else {
      return proof.generate_versioned({
        version: linkdesc.version
      }, cb);
    }
  };

  Key = (function() {
    function Key(_arg) {
      this.km = _arg.km, this.expire_in = _arg.expire_in, this.ctime = _arg.ctime, this.revoked_at = _arg.revoked_at;
    }

    Key.prototype.get_kid = function() {
      return this.km.get_ekid().toString('hex');
    };

    return Key;

  })();

  SIG_ID_SUFFIX = "0f";

  Link = (function() {
    function Link(_arg) {
      this.linkdesc = _arg.linkdesc, this.proof = _arg.proof, this.generate_res = _arg.generate_res;
    }

    Link.prototype.inner_payload_json_str = function() {
      return this.generate_res.json || this.generate_res.inner.str;
    };

    Link.prototype.get_payload_hash = function() {
      return createHash('sha256').update(this.inner_payload_json_str()).digest('hex');
    };

    Link.prototype.get_sig_id = function() {
      return this.generate_res.id + SIG_ID_SUFFIX;
    };

    Link.prototype.to_json_full = function() {
      return {
        seqno: this.proof.seqno,
        prev: this.proof.prev,
        sig: this.generate_res.armored,
        payload_hash: this.get_payload_hash(),
        sig_id: this.get_sig_id(),
        payload_json: this.inner_payload_json_str(),
        kid: this.proof.sig_eng.get_km().get_ekid().toString("hex"),
        ctime: this.proof.ctime,
        sig_version: this.linkdesc.version
      };
    };

    Link.prototype.to_json = function() {
      if ((this.linkdesc.version === 2) && this.linkdesc.stubbed) {
        return this.to_json_stubbed();
      } else {
        return this.to_json_full();
      }
    };

    Link.prototype.to_json_stubbed = function() {
      return {
        s2: this.generate_res.outer.toString('base64')
      };
    };

    return Link;

  })();

  Keyring = (function() {
    function Keyring() {
      this.bundles = [];
      this.label = {};
    }

    Keyring.prototype.to_json = function() {
      return this.bundles;
    };

    return Keyring;

  })();

  exports.Forge = Forge = (function() {
    function Forge(_arg) {
      this.chain = _arg.chain;
      this._keyring = new Keyring;
      this._links = [];
      this._link_tab = {};
      this._assertions = [];
      this._time = 0;
      this._start = null;
      this._now = null;
      this._expire_in = 0;
      this._seqno = 1;
      this._prev = null;
      this._username = null;
    }

    Forge.prototype._compute_now = function() {
      if (this._now == null) {
        this._now = unix_time();
      }
      return this._now;
    };

    Forge.prototype._get_expire_in = function(_arg) {
      var obj;
      obj = _arg.obj;
      return obj.expire_in || this._expire_in;
    };

    Forge.prototype._make_key = function(_arg, cb) {
      var bundle, esc, k, km, obj, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      km = _arg.km, obj = _arg.obj;
      esc = make_esc(cb, "_make_key");
      k = new Key({
        km: km,
        ctime: this._compute_now(),
        expire_in: this._get_expire_in({
          obj: obj
        })
      });
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._make_key"
          });
          km.export_public({
            regen: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return bundle = arguments[0];
              };
            })(),
            lineno: 138
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this._keyring.bundles.push(bundle);
          _this._keyring.label[obj.label] = k;
          return cb(null, k);
        };
      })(this));
    };

    Forge.prototype._compute_time_or_default = function(linkdesc, field) {
      if (field != null) {
        return this._compute_time(field);
      } else {
        return linkdesc.ctime;
      }
    };

    Forge.prototype._compute_time = function(o, advance) {
      var m, ret, sum, term, tmp;
      if (advance == null) {
        advance = false;
      }
      ret = (function() {
        var _i, _len, _ref2;
        if (typeof o === 'string') {
          if (o === 'now') {
            return this._compute_now();
          } else if (!(m = o.match(/^([\+-])?(\d+)$/))) {
            return null;
          } else if (m[1] != null) {
            if (m[1] === '+') {
              tmp = this._compute_now() + parseInt(m[2]);
              if (advance) {
                this._now = tmp;
              }
            } else {
              tmp = this._compute_now() - parseInt(m[2]);
            }
            return tmp;
          } else {
            tmp = parseInt(m[2]);
            if (advance) {
              this._now = tmp;
            }
            return tmp;
          }
        } else if (typeof o !== 'object') {
          return null;
        } else if (o.sum != null) {
          sum = 0;
          _ref2 = o.sum;
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            term = _ref2[_i];
            sum += this._compute_time(term);
          }
          return sum;
        } else {
          return null;
        }
      }).call(this);
      if (ret == null) {
        throw new Error("bad time: " + (JSON.stringify(o)));
      }
      return ret;
    };

    Forge.prototype._init = function(cb) {
      var e, err, t;
      try {
        this._start = (t = this.get_chain().ctime) != null ? this._compute_time(t, true) : this._compute_now();
        this._expire_in = this.get_chain().expire_in || 60 * 60 * 24 * 364 * 10;
        this._username = this.get_chain().user || "tester_ralph";
        this._uid = this.get_chain().uid || username_to_uid(this._username);
      } catch (_error) {
        e = _error;
        err = e;
      }
      return cb(err);
    };

    Forge.prototype._forge_link = function(_arg, cb) {
      var linkdesc, t, v;
      linkdesc = _arg.linkdesc;
      linkdesc.ctime = (t = linkdesc.ctime) != null ? this._compute_time(t, true) : this._compute_now();
      linkdesc.version = (v = linkdesc.version) != null ? v : 1;
      switch (linkdesc.type) {
        case 'eldest':
          return this._forge_eldest_link({
            linkdesc: linkdesc
          }, cb);
        case 'subkey':
          return this._forge_subkey_link({
            linkdesc: linkdesc
          }, cb);
        case 'sibkey':
          return this._forge_sibkey_link({
            linkdesc: linkdesc
          }, cb);
        case 'revoke':
          return this._forge_revoke_link({
            linkdesc: linkdesc
          }, cb);
        case 'track':
          return this._forge_track_link({
            linkdesc: linkdesc
          }, cb);
        case 'pgp_update':
          return this._forge_pgp_update_link({
            linkdesc: linkdesc
          }, cb);
        case 'btc':
          return this._forge_btc_link({
            linkdesc: linkdesc
          }, cb);
        default:
          return cb(new Error("unhandled link type: " + linkdesc.type), null);
      }
    };

    Forge.prototype._gen_key = function(_arg, cb) {
      var esc, key, km, obj, required, t, typ, userid, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      obj = _arg.obj, required = _arg.required;
      userid = obj.userid || this._username;
      esc = make_esc(cb, "_gen_key");
      (function(_this) {
        return (function(__iced_k) {
          var _ref2;
          if ((typ = (_ref2 = obj.key) != null ? _ref2.gen : void 0) != null) {
            (function(__iced_k) {
              switch (typ) {
                case 'eddsa':
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.kb.KeyManager.generate({}, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 225
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                  break;
                case 'dh':
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.kb.EncKeyManager.generate({}, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 227
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                  break;
                case 'pgp_rsa':
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.KeyManager.generate_rsa({
                      userid: userid
                    }, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 229
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                        funcname: "Forge._gen_key"
                      });
                      km.sign({}, esc(__iced_deferrals.defer({
                        lineno: 230
                      })));
                      __iced_deferrals._fulfill();
                    })(__iced_k);
                  });
                  break;
                case 'pgp_ecc':
                  t = _this._compute_time_or_default(obj, obj.key.generated);
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.KeyManager.generate_ecc({
                      userid: userid,
                      generated: t,
                      expire_in: {
                        primary: obj.key.expire_in
                      }
                    }, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 233
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                        funcname: "Forge._gen_key"
                      });
                      km.sign({}, esc(__iced_deferrals.defer({
                        lineno: 234
                      })));
                      __iced_deferrals._fulfill();
                    })(__iced_k);
                  });
                  break;
                default:
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    athrow(new Error("unknown key type: " + typ), __iced_deferrals.defer({
                      lineno: 236
                    }));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
              }
            })(__iced_k);
          } else {
            (function(__iced_k) {
              if (required) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                    funcname: "Forge._gen_key"
                  });
                  athrow(new Error("Required to generate key but none found"), __iced_deferrals.defer({
                    lineno: 238
                  }));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(__iced_k);
          }
        });
      })(this)((function(_this) {
        return function() {
          key = null;
          (function(__iced_k) {
            if (typeof km !== "undefined" && km !== null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                  funcname: "Forge._gen_key"
                });
                _this._make_key({
                  km: km,
                  obj: obj
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return key = arguments[0];
                    };
                  })(),
                  lineno: 241
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            return cb(null, key);
          });
        };
      })(this));
    };

    Forge.prototype._populate_proof = function(_arg) {
      var linkdesc, proof;
      linkdesc = _arg.linkdesc, proof = _arg.proof;
      proof.seqno = linkdesc.seqno || this._seqno++;
      proof.prev = linkdesc.prev || this._prev;
      proof.host = "keybase.io";
      proof.user = {
        local: {
          uid: linkdesc.uid || this._uid,
          username: linkdesc.username || this._username
        }
      };
      proof.seq_type = proofs.constants.seq_types.PUBLIC;
      proof.ctime = linkdesc.ctime;
      return proof.expire_in = this._get_expire_in({
        obj: linkdesc
      });
    };

    Forge.prototype._forge_eldest_link = function(_arg, cb) {
      var esc, key, linkdesc, proof, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_eldest_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._forge_eldest_link"
          });
          _this._gen_key({
            obj: linkdesc,
            required: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return key = arguments[0];
              };
            })(),
            lineno: 262
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          proof = new proofs.Eldest({
            sig_eng: key.km.make_sig_eng()
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
              funcname: "Forge._forge_eldest_link"
            });
            _this._sign_and_commit_link({
              linkdesc: linkdesc,
              proof: proof
            }, esc(__iced_deferrals.defer({
              lineno: 266
            })));
            __iced_deferrals._fulfill();
          })(function() {
            _this._eldest_kid = key.km.get_ekid().toString('hex');
            return cb(null);
          });
        };
      })(this));
    };

    Forge.prototype._forge_subkey_link = function(_arg, cb) {
      var err, esc, key, linkdesc, parent, proof, ref, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_subkey_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._forge_subkey_link"
          });
          _this._gen_key({
            obj: linkdesc,
            required: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return key = arguments[0];
              };
            })(),
            lineno: 274
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          parent = _this._keyring.label[(ref = linkdesc.parent)];
          (function(__iced_k) {
            if (parent == null) {
              err = new Error("Unknown parent '" + ref + "' in link '" + linkdesc.label + "'");
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                  funcname: "Forge._forge_subkey_link"
                });
                athrow(err, esc(__iced_deferrals.defer({
                  lineno: 278
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            proof = new proofs.Subkey({
              subkm: key.km,
              sig_eng: parent.km.make_sig_eng(),
              parent_kid: parent.km.get_ekid().toString('hex'),
              eldest_kid: _this._eldest_kid
            });
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_subkey_link"
              });
              _this._sign_and_commit_link({
                linkdesc: linkdesc,
                proof: proof
              }, esc(__iced_deferrals.defer({
                lineno: 285
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    Forge.prototype._forge_sibkey_link = function(_arg, cb) {
      var err, esc, key, linkdesc, proof, ref, signer, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_sibkey_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._forge_sibkey_link"
          });
          _this._gen_key({
            obj: linkdesc,
            required: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return key = arguments[0];
              };
            })(),
            lineno: 292
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          signer = _this._keyring.label[(ref = linkdesc.signer)];
          (function(__iced_k) {
            if (signer == null) {
              err = new Error("Unknown signer '" + ref + "' in link '" + linkdesc.label + "'");
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                  funcname: "Forge._forge_sibkey_link"
                });
                athrow(err, esc(__iced_deferrals.defer({
                  lineno: 296
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            proof = new proofs.Sibkey({
              sibkm: key.km,
              sig_eng: signer.km.make_sig_eng(),
              eldest_kid: _this._eldest_kid
            });
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_sibkey_link"
              });
              _this._sign_and_commit_link({
                linkdesc: linkdesc,
                proof: proof
              }, esc(__iced_deferrals.defer({
                lineno: 302
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    Forge.prototype._forge_track_link = function(_arg, cb) {
      var err, esc, linkdesc, proof, ref, signer, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_sibkey_link");
      signer = this._keyring.label[(ref = linkdesc.signer)];
      (function(_this) {
        return (function(__iced_k) {
          if (signer == null) {
            err = new Error("Unknown signer '" + ref + "' in link '" + linkdesc.label + "'");
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_track_link"
              });
              athrow(err, esc(__iced_deferrals.defer({
                lineno: 312
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          proof = new proofs.Track({
            eldest_kid: _this._eldest_kid,
            sig_eng: signer.km.make_sig_eng(),
            track: {
              "basics": {
                "id_version": 1,
                "last_id_change": 1424384373,
                "username": "t_doug"
              },
              "id": "c4c565570e7e87cafd077509abf5f619",
              "key": {
                "key_fingerprint": "23f9d8552c5d419976a8efdac11869d5bc47825f",
                "kid": "0101bdda803b93cd728b21c588c77549e5dca960d4bcc589b4b80162ecc82f3c283b0a"
              },
              "pgp_keys": [
                {
                  "key_fingerprint": "23f9d8552c5d419976a8efdac11869d5bc47825f",
                  "kid": "0101bdda803b93cd728b21c588c77549e5dca960d4bcc589b4b80162ecc82f3c283b0a"
                }
              ],
              "remote_proofs": [],
              "seq_tail": null
            }
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
              funcname: "Forge._forge_track_link"
            });
            _this._sign_and_commit_link({
              linkdesc: linkdesc,
              proof: proof
            }, esc(__iced_deferrals.defer({
              lineno: 318
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb(null);
          });
        };
      })(this));
    };

    Forge.prototype._forge_btc_link = function(_arg, cb) {
      var arg, err, esc, linkdesc, proof, ref, revoke, signer, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_sibkey_link");
      signer = this._keyring.label[(ref = linkdesc.signer)];
      (function(_this) {
        return (function(__iced_k) {
          if (signer == null) {
            err = new Error("Unknown signer '" + ref + "' in link '" + linkdesc.label + "'");
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_btc_link"
              });
              athrow(err, esc(__iced_deferrals.defer({
                lineno: 328
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          arg = {
            sig_eng: signer.km.make_sig_eng(),
            cryptocurrency: {
              type: "bitcoin",
              address: (new btcjs.Address(prng(20), 0)).toBase58Check()
            },
            eldest_kid: _this._eldest_kid
          };
          revoke = {};
          (function(__iced_k) {
            if (linkdesc.revoke != null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                  funcname: "Forge._forge_btc_link"
                });
                _this._forge_revoke_section({
                  revoke: revoke,
                  linkdesc: linkdesc
                }, esc(__iced_deferrals.defer({
                  lineno: 339
                })));
                __iced_deferrals._fulfill();
              })(function() {
                return __iced_k(arg.revoke = revoke);
              });
            } else {
              return __iced_k();
            }
          })(function() {
            proof = new proofs.Cryptocurrency(arg);
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_btc_link"
              });
              _this._sign_and_commit_link({
                linkdesc: linkdesc,
                proof: proof
              }, esc(__iced_deferrals.defer({
                lineno: 342
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    Forge.prototype._forge_revoke_link = function(_arg, cb) {
      var args, err, esc, linkdesc, proof, raw, ref, revoke, signer, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_sibkey_link");
      signer = this._keyring.label[(ref = linkdesc.signer)];
      (function(_this) {
        return (function(__iced_k) {
          if (signer == null) {
            err = new Error("Unknown parent '" + ref + "' in link '" + linkdesc.label + "'");
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_revoke_link"
              });
              athrow(err, esc(__iced_deferrals.defer({
                lineno: 352
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          revoke = {};
          args = {
            sig_eng: signer.km.make_sig_eng(),
            eldest_kid: _this._eldest_kid,
            revoke: revoke
          };
          (function(__iced_k) {
            if ((raw = linkdesc.revoke.raw) != null) {
              return __iced_k(args.revoke = raw);
            } else {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                  funcname: "Forge._forge_revoke_link"
                });
                _this._forge_revoke_section({
                  linkdesc: linkdesc,
                  revoke: revoke
                }, esc(__iced_deferrals.defer({
                  lineno: 362
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            }
          })(function() {
            proof = new proofs.Revoke(args);
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_revoke_link"
              });
              _this._sign_and_commit_link({
                linkdesc: linkdesc,
                proof: proof
              }, esc(__iced_deferrals.defer({
                lineno: 364
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    Forge.prototype._forge_revoke_section = function(_arg, cb) {
      var a, arr, err, errs, id, k, key, label, linkdesc, revoke, sigs, _i, _j, _len, _len1, _ref2, _ref3, _ref4, _ref5;
      linkdesc = _arg.linkdesc, revoke = _arg.revoke;
      err = null;
      errs = [];
      if ((key = linkdesc.revoke.key) != null) {
        if ((revoke.kid = (_ref2 = this._keyring.label[key]) != null ? _ref2.get_kid() : void 0) == null) {
          err = new Error("Cannot find key '" + key + "' to revoke in link '" + linkdesc.label + "'");
        }
      } else if ((arr = linkdesc.revoke.keys) != null) {
        revoke.kids = [];
        for (_i = 0, _len = arr.length; _i < _len; _i++) {
          a = arr[_i];
          if ((k = (_ref3 = this._keyring.label[a]) != null ? _ref3.get_kid() : void 0) != null) {
            revoke.kids.push(k);
          } else {
            errs.push("Failed to find revoke key '" + a + "' in link '" + linkdesc.label + "'");
          }
        }
      } else if ((label = linkdesc.revoke.sig) != null) {
        if ((revoke.sig_id = (_ref4 = this._link_tab[label]) != null ? _ref4.get_sig_id() : void 0) == null) {
          err = new Error("Cannot find sig '" + label + "' in link '" + linkdesc.label + "'");
        }
      } else if ((sigs = linkdesc.revoke.sigs) != null) {
        revoke.sig_ids = [];
        for (_j = 0, _len1 = sigs.length; _j < _len1; _j++) {
          label = sigs[_j];
          if ((id = (_ref5 = this._link_tab[label]) != null ? _ref5.get_sig_id() : void 0) != null) {
            revoke.sig_ids.push(id);
          } else {
            errs.push("Failed to find sig '" + label + "' in link '" + linkdesc.label + "'");
          }
        }
      }
      if (errs.length) {
        err = new Error(errs.join("; "));
      }
      return cb(err);
    };

    Forge.prototype._forge_pgp_update_link = function(_arg, cb) {
      var esc, key, lifespan, linkdesc, old_ekid, proof, uid, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_pgp_update_link");
      key = this._keyring.label[linkdesc.pgp_update_key];
      proof = new proofs.PGPUpdate({
        sig_eng: this._keyring.label[linkdesc.signer].km.make_sig_eng(),
        pgpkm: key.km,
        eldest_kid: this._eldest_kid
      });
      old_ekid = key.km.get_ekid();
      lifespan = key.km.primary.lifespan;
      lifespan.expire_in = linkdesc.key_expire_in;
      if (linkdesc.generated != null) {
        lifespan.generated = this._compute_time(linkdesc.generated);
      }
      if (uid = linkdesc.userid) {
        key.km.userids[0] = new kbpgp.opkts.UserID(uid);
      }
      key.km.clear_pgp_internal_sigs();
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._forge_pgp_update_link"
          });
          key.km.sign({}, esc(__iced_deferrals.defer({
            lineno: 422
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
              funcname: "Forge._forge_pgp_update_link"
            });
            _this._make_key({
              obj: linkdesc,
              km: key.km
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return key = arguments[0];
                };
              })(),
              lineno: 423
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_pgp_update_link"
              });
              _this._sign_and_commit_link({
                linkdesc: linkdesc,
                proof: proof
              }, esc(__iced_deferrals.defer({
                lineno: 425
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                if (!key.km.get_ekid().equals(old_ekid)) {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._forge_pgp_update_link"
                    });
                    athrow(new Error('update failed : different ekid'), esc(__iced_deferrals.defer({
                      lineno: 428
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                } else {
                  return __iced_k();
                }
              })(function() {
                return cb(null);
              });
            });
          });
        };
      })(this));
    };

    Forge.prototype._sign_and_commit_link = function(_arg, cb) {
      var esc, generate_res, link, linkdesc, proof, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc, proof = _arg.proof;
      esc = make_esc(cb, "_sign_and_commit_link");
      this._populate_proof({
        linkdesc: linkdesc,
        proof: proof
      });
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._sign_and_commit_link"
          });
          generate_proof({
            proof: proof,
            linkdesc: linkdesc
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return generate_res = arguments[0];
              };
            })(),
            lineno: 437
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          link = new Link({
            linkdesc: linkdesc,
            proof: proof,
            generate_res: generate_res
          });
          _this._prev = link.get_payload_hash();
          _this._links.push(link);
          _this._link_tab[linkdesc.label] = link;
          return cb(null);
        };
      })(this));
    };

    Forge.prototype.get_chain = function() {
      return this.chain;
    };

    Forge.prototype.forge = function(cb) {
      var esc, k, key, km, label, label_kids, label_sigs, link, linkdesc, name, out, parts, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "Forge::forge");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
            funcname: "Forge.forge"
          });
          _this._init(esc(__iced_deferrals.defer({
            lineno: 452
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (_this.chain.keys != null) {
              (function(__iced_k) {
                var _i, _k, _keys, _ref2, _results, _while;
                _ref2 = _this.chain.keys;
                _keys = (function() {
                  var _results1;
                  _results1 = [];
                  for (_k in _ref2) {
                    _results1.push(_k);
                  }
                  return _results1;
                })();
                _i = 0;
                _results = [];
                _while = function(__iced_k) {
                  var _break, _continue, _next;
                  _break = function() {
                    return __iced_k(_results);
                  };
                  _continue = function() {
                    return iced.trampoline(function() {
                      ++_i;
                      return _while(__iced_k);
                    });
                  };
                  _next = function(__iced_next_arg) {
                    _results.push(__iced_next_arg);
                    return _continue();
                  };
                  if (!(_i < _keys.length)) {
                    return _break();
                  } else {
                    name = _keys[_i];
                    parts = _ref2[name];
                    (function(__iced_k) {
                      if (parts.gen) {
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                            funcname: "Forge.forge"
                          });
                          _this._gen_key({
                            obj: parts.gen
                          }, esc(__iced_deferrals.defer({
                            lineno: 456
                          })));
                          __iced_deferrals._fulfill();
                        })(__iced_k);
                      } else {
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                            funcname: "Forge.forge"
                          });
                          kbpgp.KeyManager.import_from_armored_pgp({
                            armored: parts["public"]
                          }, esc(__iced_deferrals.defer({
                            assign_fn: (function() {
                              return function() {
                                return km = arguments[0];
                              };
                            })(),
                            lineno: 458
                          })));
                          __iced_deferrals._fulfill();
                        })(function() {
                          (function(__iced_k) {
                            __iced_deferrals = new iced.Deferrals(__iced_k, {
                              parent: ___iced_passed_deferral,
                              filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                              funcname: "Forge.forge"
                            });
                            km.merge_pgp_private({
                              armored: parts["private"]
                            }, esc(__iced_deferrals.defer({
                              lineno: 459
                            })));
                            __iced_deferrals._fulfill();
                          })(function() {
                            k = new Key({
                              km: km,
                              ctime: _this._compute_now(),
                              expire_in: _this._expire_in
                            });
                            _this._keyring.bundles.push(parts["public"]);
                            return __iced_k(_this._keyring.label[name] = k);
                          });
                        });
                      }
                    })(_next);
                  }
                };
                _while(__iced_k);
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            (function(__iced_k) {
              var _i, _len, _ref2, _results, _while;
              _ref2 = _this.get_chain().links;
              _len = _ref2.length;
              _i = 0;
              _results = [];
              _while = function(__iced_k) {
                var _break, _continue, _next;
                _break = function() {
                  return __iced_k(_results);
                };
                _continue = function() {
                  return iced.trampoline(function() {
                    ++_i;
                    return _while(__iced_k);
                  });
                };
                _next = function(__iced_next_arg) {
                  _results.push(__iced_next_arg);
                  return _continue();
                };
                if (!(_i < _len)) {
                  return _break();
                } else {
                  linkdesc = _ref2[_i];
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge.forge"
                    });
                    _this._forge_link({
                      linkdesc: linkdesc
                    }, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return out = arguments[0];
                        };
                      })(),
                      lineno: 464
                    })));
                    __iced_deferrals._fulfill();
                  })(_next);
                }
              };
              _while(__iced_k);
            })(function() {
              var _ref2, _ref3;
              label_kids = {};
              _ref2 = _this._keyring.label;
              for (label in _ref2) {
                key = _ref2[label];
                label_kids[label] = key.km.get_ekid().toString("hex");
              }
              label_sigs = {};
              _ref3 = _this._link_tab;
              for (label in _ref3) {
                link = _ref3[label];
                label_sigs[label] = link.get_sig_id();
              }
              ret = {
                chain: (function() {
                  var _i, _len, _ref4, _results;
                  _ref4 = this._links;
                  _results = [];
                  for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
                    link = _ref4[_i];
                    _results.push(link.to_json());
                  }
                  return _results;
                }).call(_this),
                keys: _this._keyring.to_json(),
                uid: _this._uid,
                username: _this._username,
                label_kids: label_kids,
                label_sigs: label_sigs
              };
              return cb(null, ret);
            });
          });
        };
      })(this));
    };

    return Forge;

  })();

}).call(this);
