// Generated by IcedCoffeeScript 1.8.0-d
(function() {
  var Forge, Key, Keyring, Link, akatch, createHash, iced, kbpgp, make_esc, proofs, unix_time, username_to_uid, __iced_k, __iced_k_noop, _ref;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  make_esc = require('iced-error').make_esc;

  _ref = require('iced-utils').util, akatch = _ref.akatch, unix_time = _ref.unix_time;

  kbpgp = require('kbpgp');

  proofs = require('keybase-proofs');

  createHash = require('crypto').createHash;

  username_to_uid = function(un) {
    return createHash('sha256').update(un).digest('hex') + "19";
  };

  Key = (function() {
    function Key(_arg) {
      this.km = _arg.km, this.expire_in = _arg.expire_in, this.ctime = _arg.ctime, this.revoked_at = _arg.revoked_at;
    }

    return Key;

  })();

  Link = (function() {
    function Link(_arg) {
      this.linkdesc = _arg.linkdesc, this.proof = _arg.proof, this.generate_res = _arg.generate_res;
    }

    Link.prototype.get_payload_hash = function() {
      return createHash('sha256').update(this.generate_res.json).digest('hex');
    };

    Link.prototype.to_json = function() {
      return {
        seqno: this.proof.seqno,
        prev: this.proof.prev,
        sig: this.generate_res.armored,
        payload_hash: this.get_payload_hash(),
        sig_id: this.generate_res.id,
        payload_json: this.generate_res.json
      };
    };

    return Link;

  })();

  Keyring = (function() {
    function Keyring() {
      this.kid = {};
      this.label = {};
    }

    return Keyring;

  })();

  exports.Forge = Forge = (function() {
    function Forge(_arg) {
      this.chain = _arg.chain;
      this._keyring = new Keyring;
      this._links = [];
      this._assertions = [];
      this._time = 0;
      this._start = null;
      this._now = null;
      this._expire_in = 0;
      this._seqno = 1;
      this._prev = null;
      this._username = null;
    }

    Forge.prototype._compute_now = function() {
      if (this._now == null) {
        this._now = unix_time();
      }
      return this._now;
    };

    Forge.prototype._get_expire_in = function(_arg) {
      var obj;
      obj = _arg.obj;
      return obj.expire_in || this._expire_in;
    };

    Forge.prototype._make_key = function(_arg) {
      var k, km, obj;
      km = _arg.km, obj = _arg.obj;
      k = new Key({
        km: km,
        ctime: this._compute_now(),
        expire_in: this._get_expire_in({
          obj: obj
        })
      });
      this._keyring.kid[km.get_ekid().toString('hex')] = k;
      this._keyring.label[obj.label] = k;
      return k;
    };

    Forge.prototype._compute_time = function(o) {
      var m, ret, sum, term, tmp;
      ret = (function() {
        var _i, _len, _ref1;
        if (typeof o === 'string') {
          if (o === 'now') {
            return this._compute_now();
          } else if (!(m = o.match(/^(\+)?(\d+)$/))) {
            return null;
          } else if (m[1] != null) {
            tmp = this._compute_now() + parseInt(m[2]);
            this._now = tmp;
            return tmp;
          } else {
            return parseInt(m[2]);
          }
        } else if (typeof o !== 'object') {
          return null;
        } else if (o.sum != null) {
          sum = 0;
          _ref1 = o.sum;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            term = _ref1[_i];
            sum += this._compute_time(term);
          }
          return sum;
        } else {
          return null;
        }
      }).call(this);
      if (ret == null) {
        throw new Error("bad time: " + (JSON.stringify(o)));
      }
      return ret;
    };

    Forge.prototype._init = function(cb) {
      var e, err, t;
      try {
        this._start = (t = this.get_chain().time) != null ? this._compute_time(t) : this._compute_now();
        this._expire_in = this.get_chain().expire_in || 60 * 60 * 24 * 364 * 10;
        this._username = this.get_chain().user || "tester_ralph";
        this._uid = this.get_chain().uid || username_to_uid(this._username);
      } catch (_error) {
        e = _error;
        err = e;
      }
      return cb(err);
    };

    Forge.prototype._forge_link = function(_arg, cb) {
      var linkdesc;
      linkdesc = _arg.linkdesc;
      switch (linkdesc.type) {
        case 'eldest':
          return this._forge_eldest_link({
            linkdesc: linkdesc
          }, cb);
        case 'subkey':
          return this._forge_subkey_link({
            linkdesc: linkdesc
          }, cb);
        case 'sibkey':
          return this._forge_sibkey_link({
            linkdesc: linkdesc
          }, cb);
        case 'revoke':
          return this._forge_revoke_link({
            linkdesc: linkdesc
          }, cb);
        default:
          return cb(new Error("unhandled link type: " + linkdesc.type), null);
      }
    };

    Forge.prototype._gen_key = function(_arg, cb) {
      var err, esc, key, km, obj, required, typ, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      obj = _arg.obj, required = _arg.required;
      esc = make_esc(cb, "_gen_key");
      err = null;
      (function(_this) {
        return (function(__iced_k) {
          var _ref1;
          if ((typ = (_ref1 = obj.key) != null ? _ref1.gen : void 0) != null) {
            (function(__iced_k) {
              switch (typ) {
                case 'eddsa':
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-test-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.kb.KeyManager.generate({}, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 131
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                  break;
                case 'dh':
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-test-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.kb.EncKeyManager.generate({}, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 133
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                  break;
                case 'pgp_rsa':
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-test-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.generate_rsa({
                      userid: _this._user
                    }, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 135
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                  break;
                case 'pgp_ecc':
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-test-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.generate_ecc({
                      userid: _this._user
                    }, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 137
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                  break;
                default:
                  return __iced_k(err = new Error("unknown key type: " + typ));
              }
            })(__iced_k);
          } else {
            return __iced_k(required ? err = new Error("Required to generate key but none found") : void 0);
          }
        });
      })(this)((function(_this) {
        return function() {
          key = (typeof km !== "undefined" && km !== null) && (err == null) ? _this._make_key({
            km: km,
            obj: obj
          }) : null;
          return cb(err, key);
        };
      })(this));
    };

    Forge.prototype._populate_proof = function(_arg) {
      var linkdesc, proof, t;
      linkdesc = _arg.linkdesc, proof = _arg.proof;
      proof.seqno = this._seqno++;
      proof.prev = this._prev;
      proof.host = "keybase.io";
      proof.user = {
        local: {
          uid: this._uid,
          username: this._username
        }
      };
      proof.seq_type = proofs.constants.seq_types.PUBLIC;
      console.error(this._compute_now());
      proof.ctime = (t = linkdesc.ctime) != null ? this._compute_time(t) : this._compute_now();
      console.error(proof.ctime);
      console.error(this._compute_now());
      return proof.expire_in = this._get_expire_in({
        obj: linkdesc
      });
    };

    Forge.prototype._forge_eldest_link = function(_arg, cb) {
      var esc, key, linkdesc, proof, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_eldest_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-test-sigchain/src/forge.iced",
            funcname: "Forge._forge_eldest_link"
          });
          _this._gen_key({
            obj: linkdesc,
            required: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return key = arguments[0];
              };
            })(),
            lineno: 165
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          proof = new proofs.Eldest({
            sig_eng: key.km.make_sig_eng()
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/node-test-sigchain/src/forge.iced",
              funcname: "Forge._forge_eldest_link"
            });
            _this._sign_and_commit_link({
              linkdesc: linkdesc,
              proof: proof
            }, esc(__iced_deferrals.defer({
              lineno: 169
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb(null);
          });
        };
      })(this));
    };

    Forge.prototype._forge_subkey_link = function(_arg, cb) {
      var esc, key, linkdesc, parent, proof, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_subkey_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-test-sigchain/src/forge.iced",
            funcname: "Forge._forge_subkey_link"
          });
          _this._gen_key({
            obj: linkdesc,
            required: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return key = arguments[0];
              };
            })(),
            lineno: 176
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          parent = _this._keyring.label[linkdesc.parent];
          proof = new proofs.Subkey({
            subkm: key.km,
            sig_eng: parent.km.make_sig_eng(),
            parent_kid: parent.km.get_ekid().toString('hex')
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/node-test-sigchain/src/forge.iced",
              funcname: "Forge._forge_subkey_link"
            });
            _this._sign_and_commit_link({
              linkdesc: linkdesc,
              proof: proof
            }, esc(__iced_deferrals.defer({
              lineno: 183
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb(null);
          });
        };
      })(this));
    };

    Forge.prototype._forge_sibkey_link = function(_arg, cb) {
      var esc, key, linkdesc, proof, signer, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_sibkey_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-test-sigchain/src/forge.iced",
            funcname: "Forge._forge_sibkey_link"
          });
          _this._gen_key({
            obj: linkdesc,
            required: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return key = arguments[0];
              };
            })(),
            lineno: 190
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          signer = _this._keyring.label[linkdesc.signer];
          proof = new proofs.Sibkey({
            sibkm: key.km,
            sig_eng: signer.km.make_sig_eng()
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/node-test-sigchain/src/forge.iced",
              funcname: "Forge._forge_sibkey_link"
            });
            _this._sign_and_commit_link({
              linkdesc: linkdesc,
              proof: proof
            }, esc(__iced_deferrals.defer({
              lineno: 196
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb(null);
          });
        };
      })(this));
    };

    Forge.prototype._sign_and_commit_link = function(_arg, cb) {
      var esc, generate_res, link, linkdesc, proof, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc, proof = _arg.proof;
      esc = make_esc(cb, "_sign_and_commit_link");
      this._populate_proof({
        linkdesc: linkdesc,
        proof: proof
      });
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-test-sigchain/src/forge.iced",
            funcname: "Forge._sign_and_commit_link"
          });
          proof.generate(esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return generate_res = arguments[0];
              };
            })(),
            lineno: 203
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          link = new Link({
            linkdesc: linkdesc,
            proof: proof,
            generate_res: generate_res
          });
          _this._prev = link.get_payload_hash();
          _this._links.push(link);
          return cb(null);
        };
      })(this));
    };

    Forge.prototype.get_chain = function() {
      return this.chain.get_data().chain;
    };

    Forge.prototype.forge = function(cb) {
      var err, esc, link, linkdesc, list, out, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "Forge::forge");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-test-sigchain/src/forge.iced",
            funcname: "Forge.forge"
          });
          _this._init(esc(__iced_deferrals.defer({
            lineno: 217
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            var _i, _len, _ref1, _results, _while;
            _ref1 = _this.get_chain().links;
            _len = _ref1.length;
            _i = 0;
            _results = [];
            _while = function(__iced_k) {
              var _break, _continue, _next;
              _break = function() {
                return __iced_k(_results);
              };
              _continue = function() {
                return iced.trampoline(function() {
                  ++_i;
                  return _while(__iced_k);
                });
              };
              _next = function(__iced_next_arg) {
                _results.push(__iced_next_arg);
                return _continue();
              };
              if (!(_i < _len)) {
                return _break();
              } else {
                linkdesc = _ref1[_i];
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/max/src/keybase/node-test-sigchain/src/forge.iced",
                    funcname: "Forge.forge"
                  });
                  _this._forge_link({
                    linkdesc: linkdesc
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return out = arguments[0];
                      };
                    })(),
                    lineno: 219
                  })));
                  __iced_deferrals._fulfill();
                })(_next);
              }
            };
            _while(__iced_k);
          })(function() {
            list = (function() {
              var _i, _len, _ref1, _results;
              _ref1 = this._links;
              _results = [];
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                link = _ref1[_i];
                _results.push(link.to_json());
              }
              return _results;
            }).call(_this);
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-test-sigchain/src/forge.iced",
                funcname: "Forge.forge"
              });
              _this.chain.output(JSON.stringify(list), __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return err = arguments[0];
                  };
                })(),
                lineno: 223
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(err);
            });
          });
        };
      })(this));
    };

    return Forge;

  })();

}).call(this);
