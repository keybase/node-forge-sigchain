// Generated by IcedCoffeeScript 1.8.0-e
(function() {
  var Forge, Key, Keyring, Link, SIG_ID_SUFFIX, UID_HEX_LEN, UID_SUFFIX, akatch, athrow, createHash, generate_proof, generate_v2_with_corruption, iced, kbpgp, make_esc, proofs, unix_time, username_to_uid, __iced_k, __iced_k_noop, _ref;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  make_esc = require('iced-error').make_esc;

  _ref = require('iced-utils').util, athrow = _ref.athrow, akatch = _ref.akatch, unix_time = _ref.unix_time;

  kbpgp = require('kbpgp');

  proofs = require('keybase-proofs');

  createHash = require('crypto').createHash;

  UID_HEX_LEN = 32;

  UID_SUFFIX = "19";

  username_to_uid = function(un) {
    var hashlen;
    hashlen = UID_HEX_LEN - 2;
    return createHash('sha256').update(un).digest('hex').slice(0, hashlen) + UID_SUFFIX;
  };

  generate_v2_with_corruption = function(_arg, cb) {
    var armored, esc, hooks, id, inner, o, opts, out, outer, pgp, proof, raw, s, short_id, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    proof = _arg.proof, opts = _arg.opts, hooks = _arg.hooks;
    esc = make_esc(cb, "generate");
    out = null;
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced"
        });
        proof._v_generate({}, esc(__iced_deferrals.defer({
          lineno: 24
        })));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced"
          });
          proof.generate_json({}, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                s = arguments[0];
                return o = arguments[1];
              };
            })(),
            lineno: 25
          })));
          __iced_deferrals._fulfill();
        })(function() {
          inner = {
            str: s,
            obj: o
          };
          if (typeof hooks.pre_generate_outer === "function") {
            hooks.pre_generate_outer({
              proof: proof,
              inner: inner
            });
          }
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced"
            });
            proof.generate_outer({
              inner: inner
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return outer = arguments[0];
                };
              })(),
              lineno: 28
            })));
            __iced_deferrals._fulfill();
          })(function() {
            if (typeof hooks.post_generate_outer === "function") {
              hooks.post_generate_outer({
                proof: proof,
                outer: outer,
                inner: inner
              });
            }
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced"
              });
              proof.sig_eng.box(outer, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    pgp = arguments[0].pgp;
                    raw = arguments[0].raw;
                    return armored = arguments[0].armored;
                  };
                })(),
                lineno: 30
              })));
              __iced_deferrals._fulfill();
            })(function() {
              var _ref1;
              if (typeof hooks.corrupt_box === "function") {
                hooks.corrupt_box({
                  inner: inner,
                  outer: outer,
                  pgp: pgp,
                  raw: raw,
                  armored: armored
                });
              }
              _ref1 = proofs.make_ids(raw), short_id = _ref1.short_id, id = _ref1.id;
              if (typeof hooks.corrupt_ids === "function") {
                hooks.corrupt_ids({
                  inner: inner,
                  outer: outer,
                  pgp: pgp,
                  raw: raw,
                  armored: armored,
                  short_id: short_id,
                  id: id
                });
              }
              out = {
                pgp: pgp,
                id: id,
                short_id: short_id,
                raw: raw,
                armored: armored,
                inner: inner,
                outer: outer
              };
              return cb(null, out);
            });
          });
        });
      };
    })(this));
  };

  generate_proof = function(_arg, cb) {
    var hooks, linkdesc, proof;
    proof = _arg.proof, linkdesc = _arg.linkdesc;
    if ((hooks = linkdesc.corrupt_v2_proof_hooks) != null) {
      return generate_v2_with_corruption({
        proof: proof,
        opts: {},
        hooks: hooks
      }, cb);
    } else {
      return proof.generate_versioned({
        version: linkdesc.version
      }, cb);
    }
  };

  Key = (function() {
    function Key(_arg) {
      this.km = _arg.km, this.expire_in = _arg.expire_in, this.ctime = _arg.ctime, this.revoked_at = _arg.revoked_at;
    }

    Key.prototype.get_kid = function() {
      return this.km.get_ekid().toString('hex');
    };

    return Key;

  })();

  SIG_ID_SUFFIX = "0f";

  Link = (function() {
    function Link(_arg) {
      this.linkdesc = _arg.linkdesc, this.proof = _arg.proof, this.generate_res = _arg.generate_res;
    }

    Link.prototype.inner_payload_json_str = function() {
      return this.generate_res.json || this.generate_res.inner.str;
    };

    Link.prototype.get_payload_hash = function() {
      return createHash('sha256').update(this.inner_payload_json_str()).digest('hex');
    };

    Link.prototype.get_sig_id = function() {
      return this.generate_res.id + SIG_ID_SUFFIX;
    };

    Link.prototype.to_json_full = function() {
      return {
        seqno: this.proof.seqno,
        prev: this.proof.prev,
        sig: this.generate_res.armored,
        payload_hash: this.get_payload_hash(),
        sig_id: this.get_sig_id(),
        payload_json: this.inner_payload_json_str(),
        kid: this.proof.sig_eng.get_km().get_ekid().toString("hex"),
        ctime: this.proof.ctime,
        sig_version: this.linkdesc.version
      };
    };

    Link.prototype.to_json = function() {
      if ((this.linkdesc.version === 2) && this.linkdesc.stubbed) {
        return this.to_json_stubbed();
      } else {
        return this.to_json_full();
      }
    };

    Link.prototype.to_json_stubbed = function() {
      return {
        s2: this.generate_res.outer.toString('base64')
      };
    };

    return Link;

  })();

  Keyring = (function() {
    function Keyring() {
      this.bundles = [];
      this.label = {};
    }

    Keyring.prototype.to_json = function() {
      return this.bundles;
    };

    return Keyring;

  })();

  exports.Forge = Forge = (function() {
    function Forge(_arg) {
      this.chain = _arg.chain;
      this._keyring = new Keyring;
      this._links = [];
      this._link_tab = {};
      this._assertions = [];
      this._time = 0;
      this._start = null;
      this._now = null;
      this._expire_in = 0;
      this._seqno = 1;
      this._prev = null;
      this._username = null;
    }

    Forge.prototype._compute_now = function() {
      if (this._now == null) {
        this._now = unix_time();
      }
      return this._now;
    };

    Forge.prototype._get_expire_in = function(_arg) {
      var obj;
      obj = _arg.obj;
      return obj.expire_in || this._expire_in;
    };

    Forge.prototype._make_key = function(_arg, cb) {
      var bundle, esc, k, km, obj, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      km = _arg.km, obj = _arg.obj;
      esc = make_esc(cb, "_make_key");
      k = new Key({
        km: km,
        ctime: this._compute_now(),
        expire_in: this._get_expire_in({
          obj: obj
        })
      });
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._make_key"
          });
          km.export_public({
            regen: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return bundle = arguments[0];
              };
            })(),
            lineno: 137
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this._keyring.bundles.push(bundle);
          _this._keyring.label[obj.label] = k;
          return cb(null, k);
        };
      })(this));
    };

    Forge.prototype._compute_time_or_default = function(linkdesc, field) {
      if (field != null) {
        return this._compute_time(field);
      } else {
        return linkdesc.ctime;
      }
    };

    Forge.prototype._compute_time = function(o, advance) {
      var m, ret, sum, term, tmp;
      if (advance == null) {
        advance = false;
      }
      ret = (function() {
        var _i, _len, _ref1;
        if (typeof o === 'string') {
          if (o === 'now') {
            return this._compute_now();
          } else if (!(m = o.match(/^([\+-])?(\d+)$/))) {
            return null;
          } else if (m[1] != null) {
            if (m[1] === '+') {
              tmp = this._compute_now() + parseInt(m[2]);
              if (advance) {
                this._now = tmp;
              }
            } else {
              tmp = this._compute_now() - parseInt(m[2]);
            }
            return tmp;
          } else {
            tmp = parseInt(m[2]);
            if (advance) {
              this._now = tmp;
            }
            return tmp;
          }
        } else if (typeof o !== 'object') {
          return null;
        } else if (o.sum != null) {
          sum = 0;
          _ref1 = o.sum;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            term = _ref1[_i];
            sum += this._compute_time(term);
          }
          return sum;
        } else {
          return null;
        }
      }).call(this);
      if (ret == null) {
        throw new Error("bad time: " + (JSON.stringify(o)));
      }
      return ret;
    };

    Forge.prototype._init = function(cb) {
      var e, err, t;
      try {
        this._start = (t = this.get_chain().ctime) != null ? this._compute_time(t, true) : this._compute_now();
        this._expire_in = this.get_chain().expire_in || 60 * 60 * 24 * 364 * 10;
        this._username = this.get_chain().user || "tester_ralph";
        this._uid = this.get_chain().uid || username_to_uid(this._username);
      } catch (_error) {
        e = _error;
        err = e;
      }
      return cb(err);
    };

    Forge.prototype._forge_link = function(_arg, cb) {
      var linkdesc, t, v;
      linkdesc = _arg.linkdesc;
      linkdesc.ctime = (t = linkdesc.ctime) != null ? this._compute_time(t, true) : this._compute_now();
      linkdesc.version = (v = linkdesc.version) != null ? v : 1;
      switch (linkdesc.type) {
        case 'eldest':
          return this._forge_eldest_link({
            linkdesc: linkdesc
          }, cb);
        case 'subkey':
          return this._forge_subkey_link({
            linkdesc: linkdesc
          }, cb);
        case 'sibkey':
          return this._forge_sibkey_link({
            linkdesc: linkdesc
          }, cb);
        case 'revoke':
          return this._forge_revoke_link({
            linkdesc: linkdesc
          }, cb);
        case 'track':
          return this._forge_track_link({
            linkdesc: linkdesc
          }, cb);
        case 'pgp_update':
          return this._forge_pgp_update_link({
            linkdesc: linkdesc
          }, cb);
        default:
          return cb(new Error("unhandled link type: " + linkdesc.type), null);
      }
    };

    Forge.prototype._gen_key = function(_arg, cb) {
      var esc, key, km, obj, required, t, typ, userid, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      obj = _arg.obj, required = _arg.required;
      userid = obj.userid || this._username;
      esc = make_esc(cb, "_gen_key");
      (function(_this) {
        return (function(__iced_k) {
          var _ref1;
          if ((typ = (_ref1 = obj.key) != null ? _ref1.gen : void 0) != null) {
            (function(__iced_k) {
              switch (typ) {
                case 'eddsa':
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.kb.KeyManager.generate({}, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 223
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                  break;
                case 'dh':
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.kb.EncKeyManager.generate({}, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 225
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                  break;
                case 'pgp_rsa':
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.KeyManager.generate_rsa({
                      userid: userid
                    }, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 227
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                        funcname: "Forge._gen_key"
                      });
                      km.sign({}, esc(__iced_deferrals.defer({
                        lineno: 228
                      })));
                      __iced_deferrals._fulfill();
                    })(__iced_k);
                  });
                  break;
                case 'pgp_ecc':
                  t = _this._compute_time_or_default(obj, obj.key.generated);
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.KeyManager.generate_ecc({
                      userid: userid,
                      generated: t,
                      expire_in: {
                        primary: obj.key.expire_in
                      }
                    }, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 231
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                        funcname: "Forge._gen_key"
                      });
                      km.sign({}, esc(__iced_deferrals.defer({
                        lineno: 232
                      })));
                      __iced_deferrals._fulfill();
                    })(__iced_k);
                  });
                  break;
                default:
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    athrow(new Error("unknown key type: " + typ), __iced_deferrals.defer({
                      lineno: 234
                    }));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
              }
            })(__iced_k);
          } else {
            (function(__iced_k) {
              if (required) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                    funcname: "Forge._gen_key"
                  });
                  athrow(new Error("Required to generate key but none found"), __iced_deferrals.defer({
                    lineno: 236
                  }));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(__iced_k);
          }
        });
      })(this)((function(_this) {
        return function() {
          key = null;
          (function(__iced_k) {
            if (typeof km !== "undefined" && km !== null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                  funcname: "Forge._gen_key"
                });
                _this._make_key({
                  km: km,
                  obj: obj
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return key = arguments[0];
                    };
                  })(),
                  lineno: 239
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            return cb(null, key);
          });
        };
      })(this));
    };

    Forge.prototype._populate_proof = function(_arg) {
      var linkdesc, proof;
      linkdesc = _arg.linkdesc, proof = _arg.proof;
      proof.seqno = linkdesc.seqno || this._seqno++;
      proof.prev = linkdesc.prev || this._prev;
      proof.host = "keybase.io";
      proof.user = {
        local: {
          uid: linkdesc.uid || this._uid,
          username: linkdesc.username || this._username
        }
      };
      proof.seq_type = proofs.constants.seq_types.PUBLIC;
      proof.ctime = linkdesc.ctime;
      return proof.expire_in = this._get_expire_in({
        obj: linkdesc
      });
    };

    Forge.prototype._forge_eldest_link = function(_arg, cb) {
      var esc, key, linkdesc, proof, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_eldest_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._forge_eldest_link"
          });
          _this._gen_key({
            obj: linkdesc,
            required: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return key = arguments[0];
              };
            })(),
            lineno: 260
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          proof = new proofs.Eldest({
            sig_eng: key.km.make_sig_eng()
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
              funcname: "Forge._forge_eldest_link"
            });
            _this._sign_and_commit_link({
              linkdesc: linkdesc,
              proof: proof
            }, esc(__iced_deferrals.defer({
              lineno: 264
            })));
            __iced_deferrals._fulfill();
          })(function() {
            _this._eldest_kid = key.km.get_ekid().toString('hex');
            return cb(null);
          });
        };
      })(this));
    };

    Forge.prototype._forge_subkey_link = function(_arg, cb) {
      var err, esc, key, linkdesc, parent, proof, ref, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_subkey_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._forge_subkey_link"
          });
          _this._gen_key({
            obj: linkdesc,
            required: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return key = arguments[0];
              };
            })(),
            lineno: 272
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          parent = _this._keyring.label[(ref = linkdesc.parent)];
          (function(__iced_k) {
            if (parent == null) {
              err = new Error("Unknown parent '" + ref + "' in link '" + linkdesc.label + "'");
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                  funcname: "Forge._forge_subkey_link"
                });
                athrow(err, esc(__iced_deferrals.defer({
                  lineno: 276
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            proof = new proofs.Subkey({
              subkm: key.km,
              sig_eng: parent.km.make_sig_eng(),
              parent_kid: parent.km.get_ekid().toString('hex'),
              eldest_kid: _this._eldest_kid
            });
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_subkey_link"
              });
              _this._sign_and_commit_link({
                linkdesc: linkdesc,
                proof: proof
              }, esc(__iced_deferrals.defer({
                lineno: 283
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    Forge.prototype._forge_sibkey_link = function(_arg, cb) {
      var err, esc, key, linkdesc, proof, ref, signer, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_sibkey_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._forge_sibkey_link"
          });
          _this._gen_key({
            obj: linkdesc,
            required: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return key = arguments[0];
              };
            })(),
            lineno: 290
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          signer = _this._keyring.label[(ref = linkdesc.signer)];
          (function(__iced_k) {
            if (signer == null) {
              err = new Error("Unknown signer '" + ref + "' in link '" + linkdesc.label + "'");
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                  funcname: "Forge._forge_sibkey_link"
                });
                athrow(err, esc(__iced_deferrals.defer({
                  lineno: 294
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            proof = new proofs.Sibkey({
              sibkm: key.km,
              sig_eng: signer.km.make_sig_eng(),
              eldest_kid: _this._eldest_kid
            });
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_sibkey_link"
              });
              _this._sign_and_commit_link({
                linkdesc: linkdesc,
                proof: proof
              }, esc(__iced_deferrals.defer({
                lineno: 300
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    Forge.prototype._forge_track_link = function(_arg, cb) {
      var err, esc, linkdesc, proof, ref, signer, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_sibkey_link");
      signer = this._keyring.label[(ref = linkdesc.signer)];
      (function(_this) {
        return (function(__iced_k) {
          if (signer == null) {
            err = new Error("Unknown signer '" + ref + "' in link '" + linkdesc.label + "'");
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_track_link"
              });
              athrow(err, esc(__iced_deferrals.defer({
                lineno: 310
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          proof = new proofs.Track({
            sig_eng: signer.km.make_sig_eng(),
            track: {
              "basics": {
                "id_version": 1,
                "last_id_change": 1424384373,
                "username": "t_doug"
              },
              "id": "c4c565570e7e87cafd077509abf5f619",
              "key": {
                "key_fingerprint": "23f9d8552c5d419976a8efdac11869d5bc47825f",
                "kid": "0101bdda803b93cd728b21c588c77549e5dca960d4bcc589b4b80162ecc82f3c283b0a"
              },
              "pgp_keys": [
                {
                  "key_fingerprint": "23f9d8552c5d419976a8efdac11869d5bc47825f",
                  "kid": "0101bdda803b93cd728b21c588c77549e5dca960d4bcc589b4b80162ecc82f3c283b0a"
                }
              ],
              "remote_proofs": [],
              "seq_tail": null
            }
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
              funcname: "Forge._forge_track_link"
            });
            _this._sign_and_commit_link({
              linkdesc: linkdesc,
              proof: proof
            }, esc(__iced_deferrals.defer({
              lineno: 315
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb(null);
          });
        };
      })(this));
    };

    Forge.prototype._forge_revoke_link = function(_arg, cb) {
      var a, args, arr, err, errs, esc, id, k, key, label, linkdesc, proof, raw, ref, revoke, signer, sigs, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_sibkey_link");
      signer = this._keyring.label[(ref = linkdesc.signer)];
      (function(_this) {
        return (function(__iced_k) {
          if (signer == null) {
            err = new Error("Unknown parent '" + ref + "' in link '" + linkdesc.label + "'");
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_revoke_link"
              });
              athrow(err, esc(__iced_deferrals.defer({
                lineno: 325
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          revoke = {};
          args = {
            sig_eng: signer.km.make_sig_eng(),
            eldest_kid: _this._eldest_kid,
            revoke: revoke
          };
          (function(__iced_k) {
            if ((key = linkdesc.revoke.key) != null) {
              (function(__iced_k) {
                var _ref1;
                if ((revoke.kid = (_ref1 = _this._keyring.label[key]) != null ? _ref1.get_kid() : void 0) == null) {
                  err = new Error("Cannot find key '" + key + "' to revoke in link '" + linkdesc.label + "'");
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._forge_revoke_link"
                    });
                    athrow(err, esc(__iced_deferrals.defer({
                      lineno: 335
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                } else {
                  return __iced_k();
                }
              })(__iced_k);
            } else {
              (function(__iced_k) {
                var _i, _len, _ref1;
                if ((arr = linkdesc.revoke.keys) != null) {
                  revoke.kids = [];
                  errs = [];
                  for (_i = 0, _len = arr.length; _i < _len; _i++) {
                    a = arr[_i];
                    if ((k = (_ref1 = _this._keyring.label[a]) != null ? _ref1.get_kid() : void 0) != null) {
                      revoke.kids.push(k);
                    } else {
                      errs.push("Failed to find revoke key '" + a + "' in link '" + linkdesc.label + "'");
                    }
                  }
                  (function(__iced_k) {
                    if (errs.length) {
                      err = new Error(errs.join("; "));
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                          funcname: "Forge._forge_revoke_link"
                        });
                        athrow(err, esc(__iced_deferrals.defer({
                          lineno: 346
                        })));
                        __iced_deferrals._fulfill();
                      })(__iced_k);
                    } else {
                      return __iced_k();
                    }
                  })(__iced_k);
                } else {
                  (function(__iced_k) {
                    if ((label = linkdesc.revoke.sig) != null) {
                      (function(__iced_k) {
                        var _ref2;
                        if ((revoke.sig_id = (_ref2 = _this._link_tab[label]) != null ? _ref2.get_sig_id() : void 0) == null) {
                          err = new Error("Cannot find sig '" + label + "' in link '" + linkdesc.label + "'");
                          (function(__iced_k) {
                            __iced_deferrals = new iced.Deferrals(__iced_k, {
                              parent: ___iced_passed_deferral,
                              filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                              funcname: "Forge._forge_revoke_link"
                            });
                            athrow(err, esc(__iced_deferrals.defer({
                              lineno: 350
                            })));
                            __iced_deferrals._fulfill();
                          })(__iced_k);
                        } else {
                          return __iced_k();
                        }
                      })(__iced_k);
                    } else {
                      (function(__iced_k) {
                        var _j, _len1, _ref2;
                        if ((sigs = linkdesc.revoke.sigs) != null) {
                          revoke.sig_ids = [];
                          errs = [];
                          for (_j = 0, _len1 = sigs.length; _j < _len1; _j++) {
                            label = sigs[_j];
                            if ((id = (_ref2 = _this._link_tab[label]) != null ? _ref2.get_sig_id() : void 0) != null) {
                              revoke.sig_ids.push(id);
                            } else {
                              errs.push("Failed to find sig '" + label + "' in link '" + linkdesc.label + "'");
                            }
                          }
                          (function(__iced_k) {
                            if (errs.length) {
                              err = new Error(errs.join("; "));
                              (function(__iced_k) {
                                __iced_deferrals = new iced.Deferrals(__iced_k, {
                                  parent: ___iced_passed_deferral,
                                  filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                                  funcname: "Forge._forge_revoke_link"
                                });
                                athrow(err, esc(__iced_deferrals.defer({
                                  lineno: 361
                                })));
                                __iced_deferrals._fulfill();
                              })(__iced_k);
                            } else {
                              return __iced_k();
                            }
                          })(__iced_k);
                        } else {
                          return __iced_k((raw = linkdesc.revoke.raw) != null ? args.revoke = raw : void 0);
                        }
                      })(__iced_k);
                    }
                  })(__iced_k);
                }
              })(__iced_k);
            }
          })(function() {
            proof = new proofs.Revoke(args);
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_revoke_link"
              });
              _this._sign_and_commit_link({
                linkdesc: linkdesc,
                proof: proof
              }, esc(__iced_deferrals.defer({
                lineno: 365
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    Forge.prototype._forge_pgp_update_link = function(_arg, cb) {
      var esc, key, lifespan, linkdesc, old_ekid, proof, uid, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_pgp_update_link");
      key = this._keyring.label[linkdesc.pgp_update_key];
      proof = new proofs.PGPUpdate({
        sig_eng: this._keyring.label[linkdesc.signer].km.make_sig_eng(),
        pgpkm: key.km,
        eldest_kid: this._eldest_kid
      });
      old_ekid = key.km.get_ekid();
      lifespan = key.km.primary.lifespan;
      lifespan.expire_in = linkdesc.key_expire_in;
      if (linkdesc.generated != null) {
        lifespan.generated = this._compute_time(linkdesc.generated);
      }
      if (uid = linkdesc.userid) {
        key.km.userids[0] = new kbpgp.opkts.UserID(uid);
      }
      key.km.clear_pgp_internal_sigs();
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._forge_pgp_update_link"
          });
          key.km.sign({}, esc(__iced_deferrals.defer({
            lineno: 394
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
              funcname: "Forge._forge_pgp_update_link"
            });
            _this._make_key({
              obj: linkdesc,
              km: key.km
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return key = arguments[0];
                };
              })(),
              lineno: 395
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_pgp_update_link"
              });
              _this._sign_and_commit_link({
                linkdesc: linkdesc,
                proof: proof
              }, esc(__iced_deferrals.defer({
                lineno: 397
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                if (!key.km.get_ekid().equals(old_ekid)) {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._forge_pgp_update_link"
                    });
                    athrow(new Error('update failed : different ekid'), esc(__iced_deferrals.defer({
                      lineno: 400
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                } else {
                  return __iced_k();
                }
              })(function() {
                return cb(null);
              });
            });
          });
        };
      })(this));
    };

    Forge.prototype._sign_and_commit_link = function(_arg, cb) {
      var esc, generate_res, link, linkdesc, proof, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc, proof = _arg.proof;
      esc = make_esc(cb, "_sign_and_commit_link");
      this._populate_proof({
        linkdesc: linkdesc,
        proof: proof
      });
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._sign_and_commit_link"
          });
          generate_proof({
            proof: proof,
            linkdesc: linkdesc
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return generate_res = arguments[0];
              };
            })(),
            lineno: 409
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          link = new Link({
            linkdesc: linkdesc,
            proof: proof,
            generate_res: generate_res
          });
          _this._prev = link.get_payload_hash();
          _this._links.push(link);
          _this._link_tab[linkdesc.label] = link;
          return cb(null);
        };
      })(this));
    };

    Forge.prototype.get_chain = function() {
      return this.chain;
    };

    Forge.prototype.forge = function(cb) {
      var esc, k, key, km, label, label_kids, label_sigs, link, linkdesc, name, out, parts, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "Forge::forge");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
            funcname: "Forge.forge"
          });
          _this._init(esc(__iced_deferrals.defer({
            lineno: 424
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (_this.chain.keys != null) {
              (function(__iced_k) {
                var _i, _k, _keys, _ref1, _results, _while;
                _ref1 = _this.chain.keys;
                _keys = (function() {
                  var _results1;
                  _results1 = [];
                  for (_k in _ref1) {
                    _results1.push(_k);
                  }
                  return _results1;
                })();
                _i = 0;
                _results = [];
                _while = function(__iced_k) {
                  var _break, _continue, _next;
                  _break = function() {
                    return __iced_k(_results);
                  };
                  _continue = function() {
                    return iced.trampoline(function() {
                      ++_i;
                      return _while(__iced_k);
                    });
                  };
                  _next = function(__iced_next_arg) {
                    _results.push(__iced_next_arg);
                    return _continue();
                  };
                  if (!(_i < _keys.length)) {
                    return _break();
                  } else {
                    name = _keys[_i];
                    parts = _ref1[name];
                    (function(__iced_k) {
                      if (parts.gen) {
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                            funcname: "Forge.forge"
                          });
                          _this._gen_key({
                            obj: parts.gen
                          }, esc(__iced_deferrals.defer({
                            lineno: 428
                          })));
                          __iced_deferrals._fulfill();
                        })(__iced_k);
                      } else {
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                            funcname: "Forge.forge"
                          });
                          kbpgp.KeyManager.import_from_armored_pgp({
                            armored: parts["public"]
                          }, esc(__iced_deferrals.defer({
                            assign_fn: (function() {
                              return function() {
                                return km = arguments[0];
                              };
                            })(),
                            lineno: 430
                          })));
                          __iced_deferrals._fulfill();
                        })(function() {
                          (function(__iced_k) {
                            __iced_deferrals = new iced.Deferrals(__iced_k, {
                              parent: ___iced_passed_deferral,
                              filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                              funcname: "Forge.forge"
                            });
                            km.merge_pgp_private({
                              armored: parts["private"]
                            }, esc(__iced_deferrals.defer({
                              lineno: 431
                            })));
                            __iced_deferrals._fulfill();
                          })(function() {
                            k = new Key({
                              km: km,
                              ctime: _this._compute_now(),
                              expire_in: _this._expire_in
                            });
                            _this._keyring.bundles.push(parts["public"]);
                            return __iced_k(_this._keyring.label[name] = k);
                          });
                        });
                      }
                    })(_next);
                  }
                };
                _while(__iced_k);
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            (function(__iced_k) {
              var _i, _len, _ref1, _results, _while;
              _ref1 = _this.get_chain().links;
              _len = _ref1.length;
              _i = 0;
              _results = [];
              _while = function(__iced_k) {
                var _break, _continue, _next;
                _break = function() {
                  return __iced_k(_results);
                };
                _continue = function() {
                  return iced.trampoline(function() {
                    ++_i;
                    return _while(__iced_k);
                  });
                };
                _next = function(__iced_next_arg) {
                  _results.push(__iced_next_arg);
                  return _continue();
                };
                if (!(_i < _len)) {
                  return _break();
                } else {
                  linkdesc = _ref1[_i];
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge.forge"
                    });
                    _this._forge_link({
                      linkdesc: linkdesc
                    }, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return out = arguments[0];
                        };
                      })(),
                      lineno: 436
                    })));
                    __iced_deferrals._fulfill();
                  })(_next);
                }
              };
              _while(__iced_k);
            })(function() {
              var _ref1, _ref2;
              label_kids = {};
              _ref1 = _this._keyring.label;
              for (label in _ref1) {
                key = _ref1[label];
                label_kids[label] = key.km.get_ekid().toString("hex");
              }
              label_sigs = {};
              _ref2 = _this._link_tab;
              for (label in _ref2) {
                link = _ref2[label];
                label_sigs[label] = link.get_sig_id();
              }
              ret = {
                chain: (function() {
                  var _i, _len, _ref3, _results;
                  _ref3 = this._links;
                  _results = [];
                  for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                    link = _ref3[_i];
                    _results.push(link.to_json());
                  }
                  return _results;
                }).call(_this),
                keys: _this._keyring.to_json(),
                uid: _this._uid,
                username: _this._username,
                label_kids: label_kids,
                label_sigs: label_sigs
              };
              return cb(null, ret);
            });
          });
        };
      })(this));
    };

    return Forge;

  })();

}).call(this);
